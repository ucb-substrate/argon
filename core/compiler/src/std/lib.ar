fn max(x0: Float, x1: Float) -> Float {
  #scope0 if x0 < x1 {
    x1
  } else {
    x0
  }
}

fn min(x0: Float, x1: Float) -> Float {
  #scope0 if x0 < x1 {
    x0
  } else {
    x1
  }
}

fn intersection(rect1: Rect, rect2: Rect) -> Rect {
    let intersection_x0 = #scope0 max(rect1.x0, rect2.x0);
    let intersection_y0 = #scope1 max(rect1.y0, rect2.y0);
    let intersection_x1 = #scope2 min(rect1.x1, rect2.x1);
    let intersection_y1 = #scope3 min(rect1.y1, rect2.y1);
    crect(x0=intersection_x0, y0=intersection_y0, x1=intersection_x1, y1=intersection_y1)
}

fn union(rect1: Rect, rect2: Rect) -> Rect {
    let union_x0 = #scope0 min(rect1.x0, rect2.x0);
    let union_y0 = #scope1 min(rect1.y0, rect2.y0);
    let union_x1 = #scope2 max(rect1.x1, rect2.x1);
    let union_y1 = #scope3 max(rect1.y1, rect2.y1);
    crect(x0=union_x0, y0=union_y0, x1=union_x1, y1=union_y1)
}

fn array(r: Rect, n: Int, xpitch: Float, ypitch: Float) -> Rect {
    #scope0 if n == 1 {
        let first_rect = rect(r.layer)!;
        eq(first_rect.w, r.w);
        eq(first_rect.h, r.h);
        first_rect
    } else {
        let subarray = #scope2 array(r, n - 1, xpitch, ypitch);
        let first_rect = rect(r.layer)!;
        eq(first_rect.w, r.w);
        eq(first_rect.h, r.h);
        eq(first_rect.x0 + xpitch, subarray.x0);
        eq(first_rect.y0 + ypitch, subarray.y0);
        let out_rect = crect();
        #scope0 if xpitch > 0. {
            eq(out_rect.x0, first_rect.x0);
            eq(out_rect.x1, subarray.x1);
        } else {
            eq(out_rect.x0, subarray.x0);
            eq(out_rect.x1, first_rect.x1);
        }
        #scope1 if ypitch > 0. {
            eq(out_rect.y0, first_rect.y0);
            eq(out_rect.y1, subarray.y1);
        } else {
            eq(out_rect.y0, subarray.y0);
            eq(out_rect.y1, first_rect.y1);
        }
        out_rect
    }
}

fn array2(r: Rect, nx: Int, ny: Int, xpitch: Float, ypitch: Float) -> Rect {
    #scope0 if ny == 1 {
        #scope0 array(r, nx, xpitch, 0.)
    } else {
        let subarray = #scope1 array2(r, nx, ny-1, xpitch, ypitch);
        let first_rect = #scope2 array(r, nx, xpitch, 0.);
        eq(first_rect.x0, subarray.x0);
        eq(first_rect.y0 + ypitch, subarray.y0);
        let out_rect = crect();
        eq(out_rect.x0, first_rect.x0);
        eq(out_rect.x1, first_rect.x1);
        #scope0 if ypitch > 0. {
            eq(out_rect.y0, first_rect.y0);
            eq(out_rect.y1, subarray.y1);
        } else {
            eq(out_rect.y0, subarray.y0);
            eq(out_rect.y1, first_rect.y1);
        }
        out_rect
    }
}

fn max_array(r: Rect, w: Float, h: Float, xpitch: Float, ypitch: Float) -> Rect {
    let nx = (((w - r.w) / xpitch) as Int + 1);
    let ny = (((h - r.h) / ypitch) as Int + 1);
    #scope0 array2(r, nx, ny, xpitch, ypitch)
}

fn eq_rect(r1: Rect, r2: Rect) {
    eq(r1.x0, r2.x0);
    eq(r1.y0, r2.y0);
    eq(r1.x1, r2.x1);
    eq(r1.y1, r2.y1);
}

fn center_rects(r1: Rect, r2: Rect) {
    eq((r1.x0 + r1.x1)/2., (r2.x0 + r2.x1)/2.);
    eq((r1.y0 + r1.y1)/2., (r2.y0 + r2.y1)/2.);
}
