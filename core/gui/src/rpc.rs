use std::net::{IpAddr, Ipv6Addr, SocketAddr};

use async_compat::CompatExt;
use compiler::compile::CompiledCell;
use futures::{
    channel::mpsc::{self, Receiver, Sender},
    future,
    prelude::*,
};
use gpui::{AsyncApp, BackgroundExecutor, Entity, ForegroundExecutor, Task};
use lsp_server::rpc::{GuiToLspClient, LspToGui};
use portpicker::pick_unused_port;
use tarpc::{
    context,
    server::{self, Channel, incoming::Incoming},
    tokio_serde::formats::Json,
};

use crate::editor::EditorState;

#[derive(Clone)]
pub struct SyncGuiToLspClient {
    app: AsyncApp,
    client: GuiToLspClient,
}

impl SyncGuiToLspClient {
    pub fn new(app: AsyncApp, lsp_addr: SocketAddr) -> Self {
        let client = app.background_executor().block(
            async move {
                let mut transport = tarpc::serde_transport::tcp::connect(lsp_addr, Json::default);
                transport.config_mut().max_frame_length(usize::MAX);

                GuiToLspClient::new(tarpc::client::Config::default(), transport.await.unwrap())
                    .spawn()
            }
            .compat(),
        );
        let client = Self { app, client };
        client
    }

    pub fn register_server(&self, state: Entity<EditorState>) {
        let port = loop {
            if let Some(port) = pick_unused_port() {
                break port;
            }
        };
        let server_addr = (IpAddr::V6(Ipv6Addr::LOCALHOST), port).into();
        let background_executor = self.app.background_executor().clone();
        let (tx, mut rx) = mpsc::channel(1);
        self.app
            .background_executor()
            .spawn(
                async move {
                    let mut listener =
                        tarpc::serde_transport::tcp::listen(&server_addr, Json::default)
                            .await
                            .unwrap();
                    listener.config_mut().max_frame_length(usize::MAX);
                    listener
                        // Ignore accept errors.
                        .filter_map(|r| futures::future::ready(r.ok()))
                        .map(tarpc::server::BaseChannel::with_defaults)
                        // Limit channels to 1 per IP.
                        .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
                        // serve is generated by the service attribute. It takes as input any type implementing
                        // the generated World trait.
                        .map(|channel| {
                            let server = GuiServer {
                                opened_cells: tx.clone(),
                            };
                            channel
                                .execute(server.serve())
                                .for_each(|t| background_executor.spawn(t))
                        })
                        // Max 10 channels.
                        .buffer_unordered(10)
                        .for_each(|_| async {})
                        .await;
                }
                .compat(),
            )
            .detach();
        let client_clone = self.client.clone();
        self.app.background_executor().block(
            async move {
                client_clone
                    .register(context::current(), server_addr)
                    .await
                    .unwrap()
            }
            .compat(),
        );
        self.app
            .spawn(async move |app| {
                loop {
                    if let Ok(Some(cell)) = rx.try_next() {
                        state
                            .update(app, |state, cx| {
                                state.update(cx, cell);
                                cx.notify();
                            })
                            .unwrap();
                    }
                }
            })
            .detach();
    }
}

#[derive(Clone)]
pub struct GuiServer {
    opened_cells: Sender<CompiledCell>,
}

impl LspToGui for GuiServer {
    async fn open_cell(mut self, _: context::Context, cell: CompiledCell) {
        println!("opening cell {cell:?}");
        self.opened_cells.send(cell).await.unwrap();
    }
}
