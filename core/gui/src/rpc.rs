use std::{
    fmt::Display,
    net::{Ipv4Addr, SocketAddr},
    time::Duration,
};

use anyhow::{Result, anyhow};
use async_compat::CompatExt;
use compiler::{
    ast::Span,
    compile::{BasicRect, CompileOutput},
};
use futures::{
    channel::mpsc::{self, Receiver, Sender},
    prelude::*,
};
use gpui::AsyncApp;
use lang_server::rpc::{DimensionParams, Gui, LangServerAction, LangServerClient};
use tarpc::{
    context,
    server::{Channel, incoming::Incoming},
    tokio_serde::formats::Json,
};
use tower_lsp_server::lsp_types::MessageType;
use tracing::error;

use crate::editor::Editor;

pub const LANG_SERVER_CLIENT_TIMEOUT: Duration = Duration::from_millis(500);

#[derive(Clone)]
pub struct SyncLangServerClient {
    app: AsyncApp,
    client: LangServerClient,
    to_exec: Sender<EditorFn>,
}

impl SyncLangServerClient {
    pub fn new(app: AsyncApp, lang_server_addr: SocketAddr) -> (Self, Receiver<EditorFn>) {
        let client = app.background_executor().block(
            async move {
                let mut transport =
                    tarpc::serde_transport::tcp::connect(lang_server_addr, Json::default);
                transport.config_mut().max_frame_length(usize::MAX);

                LangServerClient::new(tarpc::client::Config::default(), transport.await.unwrap())
                    .spawn()
            }
            .compat(),
        );
        let (to_exec, rx) = mpsc::channel(1);
        (
            Self {
                app,
                client,
                to_exec,
            },
            rx,
        )
    }

    pub fn register_server(&self) {
        let background_executor = self.app.background_executor().clone();
        let mut listener = self.app.background_executor().block(
            async {
                if let Ok(listener) =
                    tarpc::serde_transport::tcp::listen((Ipv4Addr::LOCALHOST, 12346), Json::default)
                        .await
                {
                    listener
                } else {
                    tarpc::serde_transport::tcp::listen((Ipv4Addr::LOCALHOST, 0), Json::default)
                        .await
                        .unwrap()
                }
            }
            .compat(),
        );
        let server_addr = listener.local_addr();
        let to_exec = self.to_exec.clone();
        self.app
            .background_executor()
            .spawn(
                async move {
                    listener.config_mut().max_frame_length(usize::MAX);
                    listener
                        // Ignore accept errors.
                        .filter_map(|r| futures::future::ready(r.ok()))
                        .map(tarpc::server::BaseChannel::with_defaults)
                        // Limit channels to 1 per IP.
                        .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
                        // serve is generated by the service attribute. It takes as input any type implementing
                        // the generated World trait.
                        .map(|channel| {
                            let server = GuiServer {
                                to_exec: to_exec.clone(),
                            };
                            channel
                                .execute(server.serve())
                                .for_each(|t| background_executor.spawn(t))
                        })
                        // Max 10 channels.
                        .buffer_unordered(10)
                        .for_each(|_| async {})
                        .await;
                }
                .compat(),
            )
            .detach();
        let client_clone = self.client.clone();
        match self
            .app
            .background_executor()
            .block_with_timeout(
                LANG_SERVER_CLIENT_TIMEOUT,
                async move { client_clone.register(context::current(), server_addr).await }
                    .compat()
                    .map_err(|e| format!("{}", e)),
            )
            .map_err(|_| format!("timeout after {LANG_SERVER_CLIENT_TIMEOUT:?}"))
        {
            Err(e) | Ok(Err(e)) => {
                error!("Failed to register: {e}");
                std::process::exit(1);
            }
            _ => {}
        }
    }

    pub fn select_rect(&self, span: Span) -> Result<()> {
        let client_clone = self.client.clone();
        self.app
            .background_executor()
            .block_with_timeout(
                LANG_SERVER_CLIENT_TIMEOUT,
                async move { client_clone.select_rect(context::current(), span).await }.compat(),
            )
            .map_err(|_| {
                anyhow!("timeout reaching language server after {LANG_SERVER_CLIENT_TIMEOUT:?}")
            })??;

        Ok(())
    }

    pub fn draw_rect(
        &self,
        scope_span: Span,
        var_name: String,
        rect: BasicRect<f64>,
    ) -> Result<Option<Span>> {
        let client_clone = self.client.clone();
        Ok(self
            .app
            .background_executor()
            .block_with_timeout(
                LANG_SERVER_CLIENT_TIMEOUT,
                async move {
                    client_clone
                        .draw_rect(context::current(), scope_span, var_name, rect)
                        .await
                }
                .compat(),
            )
            .map_err(|_| {
                anyhow!("timeout reaching language server after {LANG_SERVER_CLIENT_TIMEOUT:?}")
            })??)
    }

    pub fn draw_dimension(
        &self,
        scope_span: Span,
        params: DimensionParams,
    ) -> Result<Option<Span>> {
        let client_clone = self.client.clone();
        Ok(self
            .app
            .background_executor()
            .block_with_timeout(
                LANG_SERVER_CLIENT_TIMEOUT,
                async move {
                    client_clone
                        .draw_dimension(context::current(), scope_span, params)
                        .await
                }
                .compat(),
            )
            .map_err(|_| {
                anyhow!("timeout reaching language server after {LANG_SERVER_CLIENT_TIMEOUT:?}")
            })??)
    }

    pub fn edit_dimension(&self, span: Span, value: String) -> Result<Option<Span>> {
        let client_clone = self.client.clone();
        Ok(self
            .app
            .background_executor()
            .block_with_timeout(
                LANG_SERVER_CLIENT_TIMEOUT,
                async move {
                    client_clone
                        .edit_dimension(context::current(), span, value)
                        .await
                }
                .compat(),
            )
            .map_err(|_| {
                anyhow!("timeout reaching language server after {LANG_SERVER_CLIENT_TIMEOUT:?}")
            })??)
    }

    pub fn add_eq_constraint(&self, scope_span: Span, lhs: String, rhs: String) -> Result<()> {
        let client_clone = self.client.clone();
        self.app
            .background_executor()
            .block_with_timeout(
                LANG_SERVER_CLIENT_TIMEOUT,
                async move {
                    client_clone
                        .add_eq_constraint(context::current(), scope_span, lhs, rhs)
                        .await
                }
                .compat(),
            )
            .map_err(|_| {
                anyhow!("timeout reaching language server after {LANG_SERVER_CLIENT_TIMEOUT:?}")
            })??;

        Ok(())
    }

    pub fn open_cell(&self, cell: String) -> Result<()> {
        let client_clone = self.client.clone();
        self.app
            .background_executor()
            .block_with_timeout(
                LANG_SERVER_CLIENT_TIMEOUT,
                async move { client_clone.open_cell(context::current(), cell).await }.compat(),
            )
            .map_err(|_| {
                anyhow!("timeout reaching language server after {LANG_SERVER_CLIENT_TIMEOUT:?}")
            })??;

        Ok(())
    }

    pub fn show_message<M: Display>(&self, typ: MessageType, message: M) -> Result<()> {
        let client_clone = self.client.clone();
        self.app
            .background_executor()
            .block_with_timeout(
                LANG_SERVER_CLIENT_TIMEOUT,
                async move {
                    client_clone
                        .show_message(context::current(), typ, format!("{}", message))
                        .await
                }
                .compat(),
            )
            .map_err(|_| {
                anyhow!("timeout reaching language server after {LANG_SERVER_CLIENT_TIMEOUT:?}")
            })??;

        Ok(())
    }

    pub fn dispatch_action(&self, action: LangServerAction) -> Result<()> {
        let client_clone = self.client.clone();
        self.app
            .background_executor()
            .block_with_timeout(
                LANG_SERVER_CLIENT_TIMEOUT,
                async move {
                    client_clone
                        .dispatch_action(context::current(), action)
                        .await
                }
                .compat(),
            )
            .map_err(|_| {
                anyhow!("timeout reaching language server after {LANG_SERVER_CLIENT_TIMEOUT:?}")
            })??;

        Ok(())
    }
}

type EditorFn = Box<dyn FnOnce(&Editor, &mut AsyncApp) + Send>;

#[derive(Clone)]
pub struct GuiServer {
    to_exec: Sender<EditorFn>,
}

impl Gui for GuiServer {
    async fn open_cell(mut self, _: context::Context, cell: CompileOutput, update: bool) {
        error!("received open cell");
        self.to_exec
            .send(Box::new(move |editor, cx| {
                let _ = cx.update(|cx| {
                    editor.open_cell(cx, cell, update);
                });
            }))
            .await
            .unwrap();
    }
    async fn set(mut self, _: tarpc::context::Context, key: String, value: String) -> () {
        match key.as_str() {
            "hierarchyDepth" => {
                self.to_exec
                    .send(Box::new(move |editor, cx| {
                        editor
                            .state
                            .update(cx, |state, cx| {
                                // TODO: Need better way to specify infinite hierarchy depth.
                                state.hierarchy_depth = value.parse().unwrap_or(usize::MAX);
                                cx.notify();
                            })
                            .unwrap();
                    }))
                    .await
                    .unwrap();
            }
            "darkMode" => {
                self.to_exec
                    .send(Box::new(move |editor, cx| {
                        if let Ok(new_mode) = value.parse() {
                            editor
                                .state
                                .update(cx, |state, cx| {
                                    // TODO: Need better way to specify infinite hierarchy depth.
                                    state.dark_mode = new_mode;
                                    cx.notify();
                                })
                                .unwrap();
                        }
                    }))
                    .await
                    .unwrap();
            }
            _ => {
                // TODO: handle errors.
            }
        }
    }

    async fn activate(mut self, _context: ::tarpc::context::Context) -> () {
        self.to_exec
            .send(Box::new(|_, cx| {
                let _ = cx.update(|cx| {
                    cx.activate(true);
                });
            }))
            .await
            .unwrap();
    }
}
