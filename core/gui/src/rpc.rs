use std::net::{IpAddr, Ipv4Addr, SocketAddr};

use async_compat::CompatExt;
use compiler::{
    ast::Span,
    compile::{BasicRect, CompileOutput},
};
use futures::{
    channel::mpsc::{self, Sender},
    prelude::*,
};
use gpui::AsyncApp;
use lsp_server::rpc::{DimensionParams, GuiToLspClient, LspToGui};
use portpicker::pick_unused_port;
use tarpc::{
    context,
    server::{Channel, incoming::Incoming},
    tokio_serde::formats::Json,
};

use crate::editor::Editor;

#[derive(Clone)]
pub struct SyncGuiToLspClient {
    app: AsyncApp,
    client: GuiToLspClient,
}

impl SyncGuiToLspClient {
    pub fn new(app: AsyncApp, lsp_addr: SocketAddr) -> Self {
        let client = app.background_executor().block(
            async move {
                let mut transport = tarpc::serde_transport::tcp::connect(lsp_addr, Json::default);
                transport.config_mut().max_frame_length(usize::MAX);

                GuiToLspClient::new(tarpc::client::Config::default(), transport.await.unwrap())
                    .spawn()
            }
            .compat(),
        );
        Self { app, client }
    }

    pub fn register_server(&self, editor: Editor) {
        let port = loop {
            if let Some(port) = pick_unused_port() {
                break port;
            }
        };
        let server_addr = (IpAddr::V4(Ipv4Addr::LOCALHOST), port).into();
        let background_executor = self.app.background_executor().clone();
        let (tx, mut rx) = mpsc::channel(1);
        self.app
            .background_executor()
            .spawn(
                async move {
                    let mut listener =
                        tarpc::serde_transport::tcp::listen(&server_addr, Json::default)
                            .await
                            .unwrap();
                    listener.config_mut().max_frame_length(usize::MAX);
                    listener
                        // Ignore accept errors.
                        .filter_map(|r| futures::future::ready(r.ok()))
                        .map(tarpc::server::BaseChannel::with_defaults)
                        // Limit channels to 1 per IP.
                        .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
                        // serve is generated by the service attribute. It takes as input any type implementing
                        // the generated World trait.
                        .map(|channel| {
                            let server = GuiServer {
                                to_exec: tx.clone(),
                            };
                            channel
                                .execute(server.serve())
                                .for_each(|t| background_executor.spawn(t))
                        })
                        // Max 10 channels.
                        .buffer_unordered(10)
                        .for_each(|_| async {})
                        .await;
                }
                .compat(),
            )
            .detach();
        let client_clone = self.client.clone();
        self.app.background_executor().block(
            async move {
                client_clone
                    .register(context::current(), server_addr)
                    .await
                    .unwrap()
            }
            .compat(),
        );
        self.app
            .spawn(async move |app| {
                loop {
                    if let Some(exec) = rx.next().await {
                        exec(&editor, app);
                    }
                }
            })
            .detach();
    }

    pub fn select_rect(&self, span: Span) {
        let client_clone = self.client.clone();
        self.app.background_executor().block(
            async move {
                client_clone
                    .select_rect(context::current(), span)
                    .await
                    .unwrap()
            }
            .compat(),
        );
    }

    pub fn draw_rect(
        &self,
        scope_span: Span,
        var_name: String,
        rect: BasicRect<f64>,
    ) -> Option<Span> {
        let client_clone = self.client.clone();
        self.app.background_executor().block(
            async move {
                client_clone
                    .draw_rect(context::current(), scope_span, var_name, rect)
                    .await
                    .unwrap()
            }
            .compat(),
        )
    }

    pub fn draw_dimension(&self, scope_span: Span, params: DimensionParams) -> Option<Span> {
        let client_clone = self.client.clone();
        self.app.background_executor().block(
            async move {
                client_clone
                    .draw_dimension(context::current(), scope_span, params)
                    .await
                    .unwrap()
            }
            .compat(),
        )
    }

    pub fn edit_dimension(&self, span: Span, value: String) -> Option<Span> {
        let client_clone = self.client.clone();
        self.app.background_executor().block(
            async move {
                client_clone
                    .edit_dimension(context::current(), span, value)
                    .await
                    .unwrap()
            }
            .compat(),
        )
    }

    pub fn add_eq_constraint(&self, scope_span: Span, lhs: String, rhs: String) {
        let client_clone = self.client.clone();
        self.app.background_executor().block(
            async move {
                client_clone
                    .add_eq_constraint(context::current(), scope_span, lhs, rhs)
                    .await
                    .unwrap()
            }
            .compat(),
        );
    }

    pub fn open_cell(&self, cell: String) {
        let client_clone = self.client.clone();
        self.app.background_executor().block(
            async move {
                client_clone
                    .open_cell(context::current(), cell)
                    .await
                    .unwrap()
            }
            .compat(),
        );
    }
}

type EditorFn = Box<dyn FnOnce(&Editor, &mut AsyncApp) + Send>;

#[derive(Clone)]
pub struct GuiServer {
    to_exec: Sender<EditorFn>,
}

impl LspToGui for GuiServer {
    async fn open_cell(mut self, _: context::Context, cell: CompileOutput, update: bool) {
        self.to_exec
            .send(Box::new(move |editor, cx| {
                editor.open_cell(cx, cell, update);
            }))
            .await
            .unwrap();
    }
    async fn set(mut self, _: tarpc::context::Context, key: String, value: String) -> () {
        match key.as_str() {
            "hierarchyDepth" => {
                self.to_exec
                    .send(Box::new(move |editor, cx| {
                        editor
                            .state
                            .update(cx, |state, cx| {
                                // TODO: Need better way to specify infinite hierarchy depth.
                                state.hierarchy_depth = value.parse().unwrap_or(usize::MAX);
                                cx.notify();
                            })
                            .unwrap();
                    }))
                    .await
                    .unwrap();
            }
            _ => {
                // TODO: handle errors.
            }
        }
    }
}
